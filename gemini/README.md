## 再帰関数を完全理解するための100本ノック

再帰関数をマスターするために、易しいものから難しいものまで、段階的に挑戦できる100の課題をリストアップしました。まずは手を動かして、再帰呼び出しの構造（ベースケースと再帰ステップ）に慣れることから始めましょう。

---

### 🔥 ウォーミングアップ (Lv. 1 - 10)：再帰の第一歩

まずは再帰関数の「お作法」に慣れるための、ごく簡単な問題です。ループを使えば簡単に書けるものを、あえて再帰で書いてみましょう。

1.  **カウントダウン:** nから0までカウントダウンする関数。
2.  **カウントアップ:** 0からnまでカウントアップする関数。
3.  **階乗の計算:** `n!` を計算する関数。
4.  **1からnまでの総和:** 1からnまでの全ての整数を足し合わせる関数。
5.  **べき乗の計算:** `x` の `n` 乗 (`x^n`) を計算する関数。
6.  **フィボナッチ数列（基本）:** n番目のフィボナッチ数を求める関数（計算効率は問わない）。
7.  **文字列の逆順表示:** 与えられた文字列を逆から1文字ずつ表示する関数。
8.  **配列（リスト）の要素を順に表示:** 配列の要素を先頭から順に1つずつ表示する関数。
9.  **特定の文字の繰り返し表示:** 指定された文字を、指定された回数だけ表示する関数。
10. **最大公約数:** ユークリッドの互除法を使って2つの数の最大公約数を求める関数。

---

### 🏃‍♀️ 初級 (Lv. 11 - 30)：基本的なデータ操作

配列（リスト）や文字列を扱い、少しずつ再帰的な考え方を応用していきます。「問題をより小さな同じ問題に分割する」感覚を掴みましょう。

11. **配列の合計値:** 配列の全要素の合計を求める関数。
12. **配列の最大値:** 配列の全要素の中から最大値を見つける関数。
13. **配列の最小値:** 配列の全要素の中から最小値を見つける関数。
14. **特定の要素の検索:** 配列内に特定の要素が含まれているか判定する関数 (`true`/`false`)。
15. **特定の要素の個数:** 配列内に特定の要素がいくつ含まれているか数える関数。
16. **文字列の長さ:** 文字列の長さを計算する関数。
17. **回文（かいぶん）判定:** 与えられた文字列が回文（前から読んでも後ろから読んでも同じ）かどうかを判定する関数。
18. **数字の各桁の和:** 整数 `n` の各桁の数字の和を求める関数 (例: 123 -> 1+2+3=6)。
19. **10進数を2進数に変換:** 10進数の整数を2進数の文字列に変換する関数。
20. **ネストしたリストの平坦化（1段階）:** `[[1, 2], [3], [4, 5]]` のようなリストを `[1, 2, 3, 4, 5]` に変換する関数。
21. **コラッツの予想:** 任意の正の整数nについて、nが偶数ならn/2、奇数なら3n+1の操作を繰り返し、1になるまでのステップ数を数える関数。
22. **パスカルの三角形:** パスカルの三角形の `n` 段目、`k` 番目の値を求める関数。
23. **ハノイの塔:** `n` 個の円盤がある場合のハノイの塔の手順を出力する関数。
24. **フィボナッチ数列（メモ化）:** Lv.6の問題をメモ化（計算結果を保存）して効率化する。
25. **繰り返し二乗法:** Lv.5のべき乗計算を、より効率的な繰り返し二乗法で実装する。
26. **配列の要素を逆順にする:** 配列の要素の並びを逆にした新しい配列を返す関数。
27. **文字列中の大文字の数を数える:** 文字列に含まれるアルファベットの大文字の数を数える関数。
28. **等差数列の和:** 初項 `a`、公差 `d`、項数 `n` の等差数列の和を求める関数。
29. **等比数列の和:** 初項 `a`、公比 `r`、項数 `n` の等比数列の和を求める関数。
30. **アッカーマン関数:** 非常に増加速度の速いアッカーマン関数 `A(m, n)` を実装してみる（小さなm, nで試すこと）。

---

### 💪 中級 (Lv. 31 - 60)：分割統治法と木構造

より再帰的な思考が活きてくる分野です。特に「分割統治法」は再帰の強力な応用例です。木構造の探索は再帰の典型的な利用シーンです。

31. **二分探索:** ソート済みの配列から特定の値を探す二分探索アルゴリズムを実装する。
32. **マージソート:** 分割統治法に基づいた有名なソートアルゴリズム、マージソートを実装する。
33. **クイックソート:** 分割統治法に基づいた効率的なソートアルゴリズム、クイックソートを実装する。
34. **二分木の探索:** 与えられた値を持つノードを二分木の中から探し出す関数。
35. **二分木の挿入:** 二分探索木のルールに従って、新しい値を木に挿入する関数。
36. **二分木の巡回（pre-order）:** 木の行きがけ順（親→左→右）でノードの値を表示する関数。
37. **二分木の巡回（in-order）:** 木の通りがけ順（左→親→右）でノードの値を表示する関数。
38. **二分木の巡回（post-order）:** 木の帰りがけ順（左→右→親）でノードの値を表示する関数。
39. **二分木の深さ:** 二分木の根から最も遠い葉までの距離（深さ）を計算する関数。
40. **二分木のノード数:** 二分木に含まれる全ノードの数を数える関数。
41. **二分木の葉の数:** 二分木に含まれる葉（子を持たないノード）の数を数える関数。
42. **対称な木かどうかの判定:** ある二分木が、その中心軸に対して対称（鏡像）であるか判定する関数。
43. **ネストしたリストの平坦化（多段階）:** `[1, [2, [3, 4], 5]]` のような深くネストしたリストを完全に平坦化する関数。
44. **フラクタル図形の描画（コッホ曲線）:** コッホ曲線を描画する手順を再帰的に生成する（描画ライブラリは問わない）。
45. **フラクタル図形の描画（シェルピンスキーのギャスケット）:** シェルピンスキーのギャスケットを描画する手順を再帰的に生成する。
46. **グリッド上の経路探索（基本）:** `m x n` のグリッドの左上から右下まで、右か下にしか進めない場合の経路の総数を数える。
47. **文字列の全ての部分文字列の生成:** "abc" から "a", "b", "c", "ab", "bc", "abc" などを全て列挙する。
48. **正しい括弧の組み合わせ:** `n` 組の括弧 `()` を使って作れる、全ての正しい組み合わせを列挙する (例: n=2 -> "(())", "()()")。
49. **ファイルシステムの探索:** 指定されたディレクトリ以下の全てのファイルとディレクトリを再帰的にリストアップする。
50. **最小共通祖先（LCA） in 二分探索木:** 二分探索木において、2つの指定されたノードの最も近い共通の親ノードを見つける。
51. **迷路探索（深さ優先探索）:** 2次元配列で表された迷路のスタートからゴールまでの経路を1つ見つける。
52. **部分和問題:** 与えられた整数の集合から、いくつかの数を選んでその和を `W` にすることができるか判定する。
53. **最長共通部分列 (LCS) の長さ:** 2つの文字列に共通して現れる部分列のうち、最も長いものの長さを求める。
54. **編集距離 (レーベンシュタイン距離):** 1つの文字列をもう1つの文字列に変えるために必要な最小操作回数（挿入、削除、置換）を求める。
55. **連結リストの逆順:** 連結リストのポインタを逆向きにして、リスト全体を逆順にする。
56. **連結リストのペアごとのスワップ:** 連結リストの要素を `(1,2), (3,4), ...` のようにペアで入れ替える。
57. **二分木が二分探索木かどうかの判定:** 与えられた二分木が、二分探索木の条件を満たしているか判定する。
58. **ソート済み配列から高さが最小の二分探索木を作成:** 昇順にソートされた配列から、高さが最小になるような二分探索木を構築する。
59. **木のパスの和:** 根から葉までのパスを数値とみなし、その合計が特定の値になるパスが存在するかどうかを判定する。
60. **相互再帰:** 2つの関数が互いに呼び出しあうような簡単なプログラムを書いてみる（例：偶数/奇数の判定）。

---

### 👹 上級 (Lv. 61 - 85)：バックトラッキングと組み合わせ最適化

複数の再帰呼び出しを組み合わせ、全ての可能性を探索する「バックトラッキング」が中心です。計算量が爆発しやすいため、効率化（枝刈り）も重要になります。

61. **順列の生成:** 与えられた文字（または数字）の集合から、ありえる全ての順列を列挙する。
62. **組み合わせの生成:** `n` 個の要素から `k` 個を選ぶ全ての組み合わせを列挙する。
63. **部分集合の生成:** 与えられた集合の全ての部分集合を列挙する（冪集合）。
64. **Nクイーン問題:** `N x N` のチェス盤に `N` 個のクイーンを、互いに攻撃しあわないように配置する全ての解を求める。
65. **数独ソルバー:** 数独の盤面を再帰的に探索し、解を求めるソルバーを実装する。
66. **迷路探索（全経路）:** 迷路のスタートからゴールまでの全ての経路を列挙する。
67. **騎士の巡歴問題:** チェス盤上のあるマスからスタートし、ナイトの動きで全てのマスを1度ずつ訪れる経路を見つける。
68. **グラフの彩色問題:** グラフの各頂点を、隣接する頂点が同じ色にならないように、指定された色数で塗り分ける。
69. **ナップサック問題（0-1 ナップサック）:** 価値と重さが異なる複数の品物があり、容量制限のあるナップサックに入れる品物の価値を最大化する。
70. **単語分割問題:** 辞書と文字列が与えられたとき、その文字列を辞書にある単語の連続で分割できるか判定する。
71. **IPアドレスの復元:** 数字のみの文字列から、有効なIPアドレスの組み合わせを全て列挙する。
72. **グラフの深さ優先探索（DFS）の実装:** 隣接リストまたは隣接行列で表現されたグラフを探索するDFSを実装する。
73. **グラフの連結成分の検出:** グラフがいくつの連結した部分グラフに分かれているか数える。
74. **式の評価:** `3 * (4 + 5)` のような文字列で与えられた数式を計算して値を返す。
75. **boggleゲームの単語検索:** `4x4` の文字盤の中から、隣接する文字を辿って作れる有効な単語を全て見つける。
76. **最小共通祖先（LCA） in 一般的な木:** 一般的な木構造（二分木とは限らない）でLCAを見つける。
77. **木をシリアライズ/デシリアライズする:** 木構造を文字列に変換し、その文字列から元の木構造を復元する。
78. **括弧の追加:** `2-1-1` のような式に括弧を追加して、計算結果がどう変わりうるか全て列挙する。
79. **タイル敷き詰め問題:** `2 x n` の盤面を `1 x 2` のドミノタイルで敷き詰める方法の総数を数える。
80. **美しい配置:** `1` から `n` までの数を並び替えた配列 `p` で、`p[i]` が `i` で割り切れるか、`i` が `p[i]` で割り切れるかのどちらかを満たす「美しい配置」の総数を数える。
81. **ゲーム理論（ミニマックス法）:** 2人対戦ゲーム（○×ゲームなど）で、自分が勝つための最善手を再帰的に探索する。
82. **α-β法:** ミニマックス法の探索を効率化するα-β枝刈りを実装する。
83. **Z-Orderカーブ（モートン順序）:** 2次元座標を1次元の値にマッピングするZ-Orderカーブの値を再帰的に計算する。
84. **タワーディフェンスの最適配置（簡易版）:** グリッド上にタワーを配置して、敵の経路を塞ぐ/攻撃する最適な配置を探す問題の簡易版。
85. **正規表現のマッチング（簡易版）:** `.`（任意の一文字）と `*`（直前の文字の0回以上の繰り返し）を含む単純な正規表現パターンに文字列がマッチするか判定する。

---

### 🌌 魔級 (Lv. 86 - 100)：高度なアルゴリズムと理論

再帰の応用として、より高度なアルゴリズムや、計算理論に近い領域に挑戦します。ここまでの問題が解ければ、あなたは再帰マスターです。

86. **構文解析器（パーサー）の作成:** 簡単な文法（例: `expr = term {('+'|'-') term}`）に従って、数式の文字列を解析し、構文木を構築する。
87. **遅延評価とメモ化:** 無限リスト（例: 自然数の無限列）を表現し、必要になった時に初めて値を計算するような構造を再帰で実現する。
88. **末尾再帰最適化:** スタックオーバーフローを起こさない末尾再帰の形で関数を書き直す練習。（言語が最適化をサポートしているか意識する）
89. **継続渡しスタイル（CPS）への変換:** 通常の再帰関数を、次の処理（継続）を引数として渡すスタイルに変換する。
90. **Yコンビネータ（不動点コンビネータ）の理解:** ラムダ計算における、匿名関数で再帰を実現するための概念をコードで表現してみる。
91. **レーティングシステムの更新計算:** オンラインゲームなどで使われるイロレーティングのような、再帰的な更新式のシミュレーション。
92. **確率的な再帰:** ランダムな要素を含む再帰関数（例：ランダム化クイックソートの期待計算量の解析など）を考察する。
93. **マンデルブロ集合の計算:** ある複素数がマンデルブロ集合に含まれるかどうかを判定する再帰的な計算を実装する。
94. **SATソルバー（DPLLアルゴリズム）の実装:** 充足可能性問題を解くための基本的なアルゴリズムであるDPLLを再帰とバックトラッキングで実装する。
95. **バイナリインデックスツリー（BIT）/ フェニック木:** 配列の区間和や更新を効率的に行うデータ構造の操作を、再帰的な構造として理解・実装する。
96. **セグメント木:** 区間に対する問い合わせを効率的に処理するセグメント木を再帰的に構築・操作する。
97. **トライ木（プリフィックス木）:** 文字列の集合を効率的に格納・検索するためのトライ木を構築し、前方一致検索などを実装する。
98. **A\*探索アルゴリズム:** ヒューリスティック関数を用いた、より効率的なグラフ探索アルゴリズムA\*を実装する。
99. **チューリングマシンのシミュレータ:** 万能計算モデルであるチューリングマシンを、状態遷移関数を再帰的に呼び出す形でシミュレートする。
100. **これまでの問題の再評価:** これまでに解いた問題（特に動的計画法に関連するもの）を、トップダウン（メモ化再帰）ではなくボトムアップ（DPテーブルを埋めるループ）で書き直し、両者の関係性を完全に理解する。

---

### 学習の進め方

* **焦らない:** 1日1問でも構いません。重要なのは、各問題で「なぜ再帰で解けるのか」「ベースケースは何か」「再帰ステップは何か」を自分の言葉で説明できるようになることです。
* **まずは図を描く:** 再帰呼び出しがどのように進んでいくか、スタックの様子や関数の呼び出しツリーを図に描いてみるのが非常に有効です。
* **デバッガを使う:** 変数の値がどのように変わっていくか、ステップ実行で追いかけてみましょう。
* **ループと比較する:** 「これをループで書くとどうなるだろう？」と考えてみることで、再帰のメリット・デメリットがより深く理解できます。

頑張ってください！この100本ノックを終える頃には、再帰的な思考が自然にできるようになっているはずです。